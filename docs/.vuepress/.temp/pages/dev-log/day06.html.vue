<template><div><h3 id="任务" tabindex="-1"><a class="header-anchor" href="#任务" aria-hidden="true">#</a> 任务</h3>
<ul>
<li>[x] ID 生成策略开发</li>
</ul>
<h3 id="学习过程" tabindex="-1"><a class="header-anchor" href="#学习过程" aria-hidden="true">#</a> 学习过程</h3>
<ol>
<li>
<p>先看视频了解用到了啥</p>
</li>
<li>
<p>看小傅哥策略模式的<a href="https://mp.weixin.qq.com/s/zOFLtSFVrYEyTuihzwgKYw" target="_blank" rel="noopener noreferrer">文章<ExternalLinkIcon/></a></p>
</li>
<li>
<p>看代码结构</p>
<ol>
<li>定义一个接口，用来生成 id</li>
<li>实现接口，实现不同的 id 生成算法</li>
<li>定义一个上下文对象，包装各种 id 生成算法，然后放到 Spring 容器中供其他类注入使用</li>
</ol>
<p>今天的代码比较简单，主要就是涉及策略模式的使用，这里的上下文对象和之前的 config 类似，都是把写好的实现类进行包装，统一放到一个容器内，然后其他类通过这个容器，配合枚举拿到对应的实现类进行调用</p>
</li>
<li>
<p>实操</p>
</li>
</ol>
<h3 id="遇到的问题" tabindex="-1"><a class="header-anchor" href="#遇到的问题" aria-hidden="true">#</a> 遇到的问题</h3>
<ol>
<li>什么是雪花算法</li>
<li>项目代码中的雪花算法为什么要这么写</li>
</ol>
<h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h3>
<ol>
<li>
<p>对策略模式的新看法</p>
<p>现在对策略模式的看法如下：</p>
<ol>
<li>将每一种策略想象成一个又一个的工具类</li>
<li>这些工具类都来自同一个接口，也就是实现的功能是类似的，比如都是生成 ID，都是用来发奖的</li>
<li>把这些工具类进行 “打包” 处理，封装在一个 Map 中，键使用枚举进行处理</li>
<li>后续使用通过注入封装好的 Map 和枚举直接进行 get 操作然后使用就可以了</li>
</ol>
<p>好处：</p>
<p>减少 if else 的次数，如果以后要进行扩展，只需要添加一个接口实现，然后在 &quot;打包&quot; 里添加一种策略就可以了，易于扩展，避免代码过度耦合，把一坨代码进行分片，功能职责划分更清楚，并且可以动态切换算法：将实现类进行更改就可以实现动态切换</p>
</li>
<li>
<p>什么是雪花算法</p>
<p>雪花算法用于生成分布式唯一 ID，核心思想如下：</p>
<ol>
<li>将一个64位的整数划分为不同的部分，每一部分代表不同的含义</li>
<li>符号位(1位)：始终为 0，表示生成的 ID 为正整数</li>
<li>时间戳(41位)：记录生成 ID 的时间戳，精确到毫秒级，41位可以表示约 69 年的时间</li>
<li>工作机器 ID(10位)：标识机器的唯一ID，用于解决分布式系统中的多节点生成 ID 的冲突问题，最多有 2^10 台机器 ，即 1024 个</li>
<li>序列号(12位)：表示同一毫秒内的序列号，用于解决同一节点在同一毫秒内生成 ID 的冲突问题，最多可以用 2 的 12 次方个 ID，也就是同一毫秒内同一机器最多生成 4096 个</li>
</ol>
<p>通俗化：确保在分布式系统中，通过对时间戳、机器和序列号进行加工，生成一个唯一 ID</p>
<p>了解了这个东西就能理解项目中为啥要这么写了，后面看看雪花算法的具体源码，看看每个部分如何进行加工的</p>
</li>
<li>
<p>短码生成的时候进行打乱和再加工</p>
<p>因为没有实际项目经验之前就是直接拿当前时间戳进行获取的，没有进行打乱操作，以后要记住这个操作，避免项目数据被别人抓个包一下子就猜出来了 -.- 好歹穿件衣服，不能裸奔</p>
</li>
<li>
<p>预习预习明天的内容，哈哈哈，好像要开始上强度了，昨天亲戚结婚忙了一天，半夜才回来，今天就到这把，查点资料预习预习明天的，感觉 DDD 这种包组织方式特别适合每种设计模式和算法的落地，MVC 如果想要算法和设计模式落地的话，感觉要考虑的东西很多很多，要么就是牵一发而动全身，要么就是落地之后包里面有很多的多余的东西，这种方式则不会出现这种情况，一个领域里面，使用一种设计模式，并不会影响其他的包，其他的包只管调用所提供的接口就好了</p>
</li>
</ol>
</div></template>


