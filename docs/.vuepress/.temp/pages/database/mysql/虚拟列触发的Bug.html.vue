<template><div><p>背景：新增虚拟列导致异地机房同步延迟问题</p>
<p>表现：业务受影响。</p>
<p>因为N个数据库实例放在同一个服务器实例上，其中一个数据库实例因新增虚拟列，使得异地机房无法同步。从而导致数据库CPU从20%升到105%，数据库QPS从6K飙升到45K，还有慢查询，逻辑读，物理读，连接数全都飙升。</p>
<p>（新增一张主从同步的图：直角三角形）</p>
<p>因为N个数据库实例在同一个服务器实例上，好吧，因为一颗老鼠屎搅浑一锅粥，直接一锅端。恰好这N个数据库都是核心数据库。结果就是整个业务崩溃。万幸的是，业务低峰期。不幸的是，持续了一个多小时，及时已经把流量已经切到从库了。但奈何影响还是存在的。</p>
<p>接下来就复盘，大家应该会有很多疑问</p>
<p>1、为什么新增虚拟列，会导致异地机房无法同步数据问题？</p>
<p>D：首先，mysql在5.7版本是已经支持虚拟列的。但异地多活的数据库机房，不支持虚拟列的数据同步。</p>
<p>2、为什么允许新增虚拟列，但却不能进行数据同步？</p>
<p>D：就是SQL都校验通过了，最后却说不能进行异地机房同步，这个锅，业务不背，数据库背吧。因为数据库规范里面没说不允许建虚拟索引，还有SQL校验都通过了。</p>
<p>3、为什么会把N个核心数据库放在同一个服务器实例上啊？</p>
<p>D：一说没资源，二说没时间。</p>
<p>4、什么是虚拟列，为啥不新增普通列？</p>
<blockquote>
<p>MySQL中的虚拟列是一种特殊的列，分VIRTUAL 和 STORED 2种类型。</p>
<p><strong>VIRTUAL 虚拟列：</strong></p>
<ul>
<li>VIRTUAL 虚拟列是通过表达式动态计算得出的值，并不实际存储在磁盘上。</li>
<li>每次查询时，虚拟列的值都会根据定义的表达式进行计算。</li>
<li>虚拟列的值是实时计算的，不占用额外的存储空间。</li>
<li>适用于那些能够通过其他列计算得出的值，而且计算开销较小的情况。</li>
</ul>
<p><strong>STORED 虚拟列：</strong></p>
<p>STORED 虚拟列也是通过表达式计算得出的值，但与 VIRTUAL 不同，STORED 虚拟列的值在插入或更新数据时计算并存储在磁盘上。
存储列的值只有在写入时计算一次，并且在查询时直接读取存储的值，不需要再进行实时计算。
适用于那些频繁被查询而计算开销较高的场景，可以在写入数据时计算一次，然后在查询时直接读取存储的值，提高查询性能</p>
</blockquote>
</div></template>


