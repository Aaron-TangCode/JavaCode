---
title: 虚拟列触发的Bug
index: false
category:
  - 生产事故
---

背景：新增虚拟列导致异地机房同步延迟问题



表现：业务受影响。



因为N个数据库实例放在同一个服务器实例上，其中一个数据库实例因新增虚拟列，使得异地机房无法同步。从而导致数据库CPU从20%升到105%，数据库QPS从6K飙升到45K，还有慢查询，逻辑读，物理读，连接数全都飙升。

（新增一张主从同步的图：直角三角形）



因为N个数据库实例在同一个服务器实例上，好吧，因为一颗老鼠屎搅浑一锅粥，直接一锅端。恰好这N个数据库都是核心数据库。结果就是整个业务崩溃。万幸的是，业务低峰期。不幸的是，持续了一个多小时，及时已经把流量已经切到从库了。但奈何影响还是存在的。



接下来就复盘，大家应该会有很多疑问

1、为什么新增虚拟列，会导致异地机房无法同步数据问题？

D：首先，mysql在5.7版本是已经支持虚拟列的。但异地多活的数据库机房，不支持虚拟列的数据同步。

2、为什么允许新增虚拟列，但却不能进行数据同步？

D：就是SQL都校验通过了，最后却说不能进行异地机房同步，这个锅，业务不背，数据库背吧。因为数据库规范里面没说不允许建虚拟索引，还有SQL校验都通过了。

3、为什么会把N个核心数据库放在同一个服务器实例上啊？

D：一说没资源，二说没时间。

4、什么是虚拟列，为啥不新增普通列？

> MySQL中的虚拟列是一种特殊的列，分VIRTUAL 和 STORED 2种类型。
>
> **VIRTUAL 虚拟列：**
>
> - VIRTUAL 虚拟列是通过表达式动态计算得出的值，并不实际存储在磁盘上。
> - 每次查询时，虚拟列的值都会根据定义的表达式进行计算。
> - 虚拟列的值是实时计算的，不占用额外的存储空间。
> - 适用于那些能够通过其他列计算得出的值，而且计算开销较小的情况。
>
> **STORED 虚拟列：**
>
> STORED 虚拟列也是通过表达式计算得出的值，但与 VIRTUAL 不同，STORED 虚拟列的值在插入或更新数据时计算并存储在磁盘上。
> 存储列的值只有在写入时计算一次，并且在查询时直接读取存储的值，不需要再进行实时计算。
> 适用于那些频繁被查询而计算开销较高的场景，可以在写入数据时计算一次，然后在查询时直接读取存储的值，提高查询性能
>
> 

















