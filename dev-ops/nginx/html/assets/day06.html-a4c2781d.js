import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{r as o,o as a,c as t,a as l,d as e,e as r,f as s}from"./app-89848b6d.js";const d={},c=l("h3",{id:"任务",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#任务","aria-hidden":"true"},"#"),e(" 任务")],-1),p=l("ul",null,[l("li",null,"[x] ID 生成策略开发")],-1),h=l("h3",{id:"学习过程",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#学习过程","aria-hidden":"true"},"#"),e(" 学习过程")],-1),_=l("li",null,[l("p",null,"先看视频了解用到了啥")],-1),u={href:"https://mp.weixin.qq.com/s/zOFLtSFVrYEyTuihzwgKYw",target:"_blank",rel:"noopener noreferrer"},f=l("li",null,[l("p",null,"看代码结构"),l("ol",null,[l("li",null,"定义一个接口，用来生成 id"),l("li",null,"实现接口，实现不同的 id 生成算法"),l("li",null,"定义一个上下文对象，包装各种 id 生成算法，然后放到 Spring 容器中供其他类注入使用")]),l("p",null,"今天的代码比较简单，主要就是涉及策略模式的使用，这里的上下文对象和之前的 config 类似，都是把写好的实现类进行包装，统一放到一个容器内，然后其他类通过这个容器，配合枚举拿到对应的实现类进行调用")],-1),D=l("li",null,[l("p",null,"实操")],-1),I=s('<h3 id="遇到的问题" tabindex="-1"><a class="header-anchor" href="#遇到的问题" aria-hidden="true">#</a> 遇到的问题</h3><ol><li>什么是雪花算法</li><li>项目代码中的雪花算法为什么要这么写</li></ol><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h3><ol><li><p>对策略模式的新看法</p><p>现在对策略模式的看法如下：</p><ol><li>将每一种策略想象成一个又一个的工具类</li><li>这些工具类都来自同一个接口，也就是实现的功能是类似的，比如都是生成 ID，都是用来发奖的</li><li>把这些工具类进行 “打包” 处理，封装在一个 Map 中，键使用枚举进行处理</li><li>后续使用通过注入封装好的 Map 和枚举直接进行 get 操作然后使用就可以了</li></ol><p>好处：</p><p>减少 if else 的次数，如果以后要进行扩展，只需要添加一个接口实现，然后在 &quot;打包&quot; 里添加一种策略就可以了，易于扩展，避免代码过度耦合，把一坨代码进行分片，功能职责划分更清楚，并且可以动态切换算法：将实现类进行更改就可以实现动态切换</p></li><li><p>什么是雪花算法</p><p>雪花算法用于生成分布式唯一 ID，核心思想如下：</p><ol><li>将一个64位的整数划分为不同的部分，每一部分代表不同的含义</li><li>符号位(1位)：始终为 0，表示生成的 ID 为正整数</li><li>时间戳(41位)：记录生成 ID 的时间戳，精确到毫秒级，41位可以表示约 69 年的时间</li><li>工作机器 ID(10位)：标识机器的唯一ID，用于解决分布式系统中的多节点生成 ID 的冲突问题，最多有 2^10 台机器 ，即 1024 个</li><li>序列号(12位)：表示同一毫秒内的序列号，用于解决同一节点在同一毫秒内生成 ID 的冲突问题，最多可以用 2 的 12 次方个 ID，也就是同一毫秒内同一机器最多生成 4096 个</li></ol><p>通俗化：确保在分布式系统中，通过对时间戳、机器和序列号进行加工，生成一个唯一 ID</p><p>了解了这个东西就能理解项目中为啥要这么写了，后面看看雪花算法的具体源码，看看每个部分如何进行加工的</p></li><li><p>短码生成的时候进行打乱和再加工</p><p>因为没有实际项目经验之前就是直接拿当前时间戳进行获取的，没有进行打乱操作，以后要记住这个操作，避免项目数据被别人抓个包一下子就猜出来了 -.- 好歹穿件衣服，不能裸奔</p></li><li><p>预习预习明天的内容，哈哈哈，好像要开始上强度了，昨天亲戚结婚忙了一天，半夜才回来，今天就到这把，查点资料预习预习明天的，感觉 DDD 这种包组织方式特别适合每种设计模式和算法的落地，MVC 如果想要算法和设计模式落地的话，感觉要考虑的东西很多很多，要么就是牵一发而动全身，要么就是落地之后包里面有很多的多余的东西，这种方式则不会出现这种情况，一个领域里面，使用一种设计模式，并不会影响其他的包，其他的包只管调用所提供的接口就好了</p></li></ol>',4);function m(x,V){const i=o("ExternalLinkIcon");return a(),t("div",null,[c,p,h,l("ol",null,[_,l("li",null,[l("p",null,[e("看小傅哥策略模式的"),l("a",u,[e("文章"),r(i)])])]),f,D]),I])}const k=n(d,[["render",m],["__file","day06.html.vue"]]);export{k as default};
