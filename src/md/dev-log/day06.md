---
title: Day06
index: false
icon: laptop-code
category:
  - 开发笔记
  - 学习记录
---

### 任务

- [x] ID 生成策略开发

### 学习过程

1. 先看视频了解用到了啥

2. 看小傅哥策略模式的[文章](https://mp.weixin.qq.com/s/zOFLtSFVrYEyTuihzwgKYw)

3. 看代码结构

   1. 定义一个接口，用来生成 id
   2. 实现接口，实现不同的 id 生成算法
   3. 定义一个上下文对象，包装各种 id 生成算法，然后放到 Spring 容器中供其他类注入使用

   今天的代码比较简单，主要就是涉及策略模式的使用，这里的上下文对象和之前的 config 类似，都是把写好的实现类进行包装，统一放到一个容器内，然后其他类通过这个容器，配合枚举拿到对应的实现类进行调用

4. 实操

### 遇到的问题

1. 什么是雪花算法
2. 项目代码中的雪花算法为什么要这么写

### 总结

1. 对策略模式的新看法

   现在对策略模式的看法如下：

   1. 将每一种策略想象成一个又一个的工具类
   2. 这些工具类都来自同一个接口，也就是实现的功能是类似的，比如都是生成 ID，都是用来发奖的
   3. 把这些工具类进行 “打包” 处理，封装在一个 Map 中，键使用枚举进行处理
   4. 后续使用通过注入封装好的 Map 和枚举直接进行 get 操作然后使用就可以了

   好处：

   减少 if else 的次数，如果以后要进行扩展，只需要添加一个接口实现，然后在 "打包" 里添加一种策略就可以了，易于扩展，避免代码过度耦合，把一坨代码进行分片，功能职责划分更清楚，并且可以动态切换算法：将实现类进行更改就可以实现动态切换

2. 什么是雪花算法

   雪花算法用于生成分布式唯一 ID，核心思想如下：

   1. 将一个64位的整数划分为不同的部分，每一部分代表不同的含义
   2. 符号位(1位)：始终为 0，表示生成的 ID 为正整数
   3. 时间戳(41位)：记录生成 ID 的时间戳，精确到毫秒级，41位可以表示约 69 年的时间
   4. 工作机器 ID(10位)：标识机器的唯一ID，用于解决分布式系统中的多节点生成 ID 的冲突问题，最多有 2^10 台机器 ，即 1024 个
   5. 序列号(12位)：表示同一毫秒内的序列号，用于解决同一节点在同一毫秒内生成 ID 的冲突问题，最多可以用 2 的 12 次方个 ID，也就是同一毫秒内同一机器最多生成 4096 个

   通俗化：确保在分布式系统中，通过对时间戳、机器和序列号进行加工，生成一个唯一 ID

   了解了这个东西就能理解项目中为啥要这么写了，后面看看雪花算法的具体源码，看看每个部分如何进行加工的

3. 短码生成的时候进行打乱和再加工

   因为没有实际项目经验之前就是直接拿当前时间戳进行获取的，没有进行打乱操作，以后要记住这个操作，避免项目数据被别人抓个包一下子就猜出来了 -.- 好歹穿件衣服，不能裸奔

4. 预习预习明天的内容，哈哈哈，好像要开始上强度了，昨天亲戚结婚忙了一天，半夜才回来，今天就到这把，查点资料预习预习明天的，感觉 DDD 这种包组织方式特别适合每种设计模式和算法的落地，MVC 如果想要算法和设计模式落地的话，感觉要考虑的东西很多很多，要么就是牵一发而动全身，要么就是落地之后包里面有很多的多余的东西，这种方式则不会出现这种情况，一个领域里面，使用一种设计模式，并不会影响其他的包，其他的包只管调用所提供的接口就好了